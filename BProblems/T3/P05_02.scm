;; INFINITE SEQUENCES AS FINITE STREAMS

(define (integers-starting-from n)
  ; Recursive definition 
  ; stream_1: (1, .) -> (stream_2)
  ; stream_2: (2, .) -> (stream_3)
  ; stream_n: (n, .) -> (stream_(n+1))
  (cons-stream n (integers-starting-from (+ n 1)))
)

; Set of positive integers, which is infinite
(define integers (integers-starting-from 1))

; Example of usage: filter integer that are not divisible by 7

(define (divisible? x y) (= (remainder x y) 0))

(define no-sevens
  (stream-filter 
    ; Filter predicate: only keep those not divisible by 7
    (lambda (x) (not (divisible? x 7)))
    ; Set to filter from
    integers
  )
)

(define no-seven-integers no-sevens)
(print no-seven-integers)
; 1
(print (stream-cdr no-seven-integers))
; 2
(print (stream-cdr (stream-cdr no-seven-integers)))
; 3
(print (stream-cdr (stream-cdr (stream-cdr no-seven-integers))))
; 4
(print (stream-cdr (stream-cdr (stream-cdr (stream-cdr no-seven-integers)))))
; 5
(print (stream-cdr (stream-cdr (stream-cdr (stream-cdr (stream-cdr no-seven-integers))))))
; 6
(print (stream-cdr (stream-cdr (stream-cdr (stream-cdr (stream-cdr (stream-cdr no-seven-integers)))))))
; 8
(print (stream-ref no-seven-integers 100))
; 117

;;; FIBONACCI SEQUENCE DEFINED WITH STRINGS

; By definition the fibonacci sequence F_n is as follows:
; F(0) = 0
; F(1) = 1
; F(k) = F(k-1) + F(k-2), for every integer k >= 2

(define (fibgen a b) 
  (cons-stream 
    a 
    ; To obtain F(k), sum a(= F(k-2)) and b(=F(k-1))
    (fibgen b (+ a b))
  )
)

; By the definition
(define fibs (fibgen 0 1))
(print (stream-ref fibs 5))
; 5


;; SET OF PRIME NUMBERS WITH STREAMS

; Using the sieve of Erastosthenes

; Construct the prime numbers by a sieving process
; To sieve a stream S, form a stream whose first element is the first
; element of S and the rest of which is obtained by filtering all multiples
; of the first element of S out of the rest of S and sieving the result.

; For example:
; We start with the integers beginning with 2, which is the first prime. To get the rest of
; the primes, we start by filtering the multiples of 2 from the rest of the integers. is leaves 
; a stream beginning with 3. And so on and so forth.

; Given a stream (it will start with the first prime 2)
(define (sieve stream)
  (cons-stream
    ; Save the first element to the final stream
    (stream-car stream)
    ; Sieve the rest of the elements
    (sieve 
      ; Filter them
      (stream-filter
        ; Filter predicate: keep only the elements not divisible by 
        ; the first element of the current stream (in the 1st iteration is 2, in the 2nd is 3, etc)
        (lambda 
          (x)
          (not (divisible? x (stream-car stream)))
        )
        ; Set to filter from: all the elements of the stream minus the first one
        (stream-cdr stream)
      )
    )
  )
)

; Sieve all the integers greater or equal to 2 to obtain the set of prime numbers
(define primes (sieve (integers-starting-from 2)))

(print (stream-ref primes 0))
; 2
(print (stream-ref primes 1))
; 3
(print (stream-ref primes 2))
; 5


;;; DEFINE STREAMS IMPLICITLY

; Define a stream of ones recursively
(define ones (cons-stream 1 ones))

; Define an elementwise sum between two streams
(define (add-streams s1 s2) (stream-map + s1 s2))

; Define the set of positive integers as

; This defines integers to be a stream whose first element is 1 and the rest
; of which is the sum of ones and integers. Thus, the second element of
; integers is 1 plus the first element of integers, or 2; the third element
; of integers is 1 plus the second element of integers, or 3; and so on

(define integers
  (cons-stream 1 (add-streams ones integers))
)

(print (stream-ref integers 0))
; 1
(print (stream-ref integers 10))
; 11

; Fibonacci numbers 

; ITER 0
; fibs = 0 1 ...

; ITER 1
;   0 1 ... (=fibs)
; + 1 ...   (=(stream-cdr fibs))
; ----------
;   1 ...
; So fibs = 0 1 1 ...

; ITER 2
;   0 1 1...  (=fibs)
; + 1 1...    (=(stream-cdr fibs))
; -----------
;   1 2 ...
; So fibs = 0 1 1 2 ...

; ITER 3
;   0 1 1 2 ... (=fibs)
; + 1 1 2 ...   (=(stream-cdr fibs))
; -----------
;   1 2 3 ...
; So fibs = 0 1 1 2 3 ...

; ITER 4
;   0 1 1 2 3 ... (=fibs)
; + 1 1 2 3 ...   (=(stream-cdr fibs))
; -----------
;   1 2 3 5..
; So fibs = 0 1 1 2 3 5 ...

(define fibs
  ; fibs is a stream beginning with 0 and 1
  (cons-stream
    0 
    (cons-stream 
      1 
      ; the rest of the stream can be generated by adding fibs to itself shifted one place
      (add-streams 
        ; fib shifted one place
        (stream-cdr fibs) 
        ; fib
        fibs
      )
    )
  )
)


(print (stream-ref fibs 5))
; 5

;; ANOTHER EXAMPLE OF USAGE OF STREAMS

;; Multiply each item in a stream by a given constant

(define (scale-stream stream factor)
  (stream-map 
    (lambda (x) (* x factor))
    stream
  )
)

(define double (cons-stream 1 (scale-stream double 2)))

(print (stream-ref double 0))
; 1
(print (stream-ref double 5))
; 2⁵ = 32


;; DEFINE THE SET OF PRIME NUMBERS WITH IMPLICIT STREAMS

(define (square x) (* x x))

; We check if an integer n is prime if n is divisible by a prime
; less than or equal to sqrt(n)
(define (prime? n)
  (define (iter ps)
    (cond 
      ; If there is a prime in the stream bigger than sqrt(n), then n is prime
      ((> (square (stream-car ps)) n) true)
      ; If it is divisible by another prime, it is not prime
      ((divisible? n (stream-car ps)) false)
      ; Else keep searching
      (else (iter (stream-cdr ps)))
    )
  )
  ; Recursive definition -> primes is defined in terms of prime?
  (iter primes)
)

(define primes
  ; Start with 2
  (cons-stream
    2 
    ; Filter by checking if the number is prime
    (stream-filter 
      prime? 
      (integers-starting-from 3)
    )
  )
)

(print (stream-ref primes 2))
; 5
